## 问题与原因分析
- 现状：在 `app/generation-result.tsx`，主预览图与缩略图均使用 `react-native` 的 `Image`，未做预取或磁盘缓存；切换缩略图仅更新 `selectedImageIndex`，每次都会重新拉取并解码大图。
- 影响因素：
  - 生成结果图片分辨率较高，首次下载与解码耗时。
  - 未进行预取与本地缓存（内存/磁盘），切换时重新请求。
  - 仅在 `onLoad` 后计算尺寸（`handleImageLoad`），切换时触发现有逻辑与重渲染。

## 解决方案选项
1) 使用 `expo-image` 替换 `react-native` 的 `Image`
- 优势：原生内存/磁盘缓存、渐进过渡、占位/模糊图、硬件加速解码。
- 做法：
  - 引入：`import { Image as ExpoImage } from 'expo-image'`
  - 主预览：`<ExpoImage source={{ uri }} contentFit="contain" cachePolicy="disk" transition={200} />`
  - 缩略图：同样使用 `ExpoImage` 并设置 `cachePolicy="disk"`。
  - 可选：设置 `placeholder`（低清图/blurhash）与 `recyclingKey`（稳定复用）。

2) 预取与本地缓存（不依赖库）
- 使用 `Image.prefetch(url)` 在生成完成后对所有 `generatedImages` 进行预取。
- 或者：用 `expo-file-system` 下载到 `FileSystem.cacheDirectory`，将远程 URL 映射为 `file://` 本地路径，后续切换使用本地路径，避免重复网络请求。

3) 预渲染/保持挂载
- 在预览容器中将 4 张图都挂载（隐藏非选中项，仅切换 `opacity`/`zIndex`），首次加载完后切换秒显。
- 风险：内存占用增加，但仅 4 张图通常可接受。

4) 服务端降采样与渐进图
- 若后端支持按宽度参数返回缩略与预览（例如 `?w=700`），主预览仅拉取适配容器宽度的版本。
- 提供低清占位图（blurhash/缩略），与 `expo-image` 的 `placeholder` 配合，提升首帧体验。

## 推荐实施步骤（最小改动优先）
- 步骤 A：替换为 `expo-image` 并开启磁盘缓存
  - 主预览：`ExpoImage` + `contentFit="contain"` + `cachePolicy="disk"` + `transition={200}`
  - 缩略图：`ExpoImage` + `cachePolicy="disk"`
- 步骤 B：生成完成后执行预取
  - 在设置 `generatedImages` 后：`await Promise.all(generatedImages.map(url => Image.prefetch(url)))`
  - 或并行下载到本地：`downloadAsync(url, FileSystem.cacheDirectory + filename)`，维护 `url → localUri` 映射。
- 步骤 C：预渲染 4 张预览图
  - 在预览容器里同时渲染 4 张 `ExpoImage`，通过 `selectedImageIndex` 控制显示状态（`opacity`/`pointerEvents`），避免切换时重新挂载。
- 步骤 D（可选）：后端返回合适尺寸
  - 将生成/存储的图片提供 `?w=` 参数或生成 700px 预览，更新前端使用该链接用于主预览。

## 代码改动要点（概述）
- `app/generation-result.tsx`
  - 引入：`import { Image as ExpoImage } from 'expo-image'`
  - 预览图：用 `ExpoImage` 替换 `Image`，设置缓存与过渡；保留 `onLoad` 维持现有尺寸逻辑。
  - 缩略图：同样改为 `ExpoImage`，减少首次进入缩略卡顿。
  - 在生成完成逻辑处添加 `prefetch` 或 `downloadAsync`，将本地缓存 URI 替换到 `generatedImages`。
  - 预渲染：在预览区域根据 `imageCount` 渲染所有图片，非选中项设置 `opacity: 0` 与 `position: 'absolute'`。

## 验证
- iOS 模拟器与真机：生成 4 张图后，切换底部缩略图时主图切换应接近瞬时（无白屏闪烁）。
- 网络关闭后切换：若采用本地缓存，应仍能显示已下载图片。
- 性能日志：记录切换耗时（`console.time/console.timeEnd`）与首帧时间。

## 回退策略
- 若不希望引入 `expo-image`，仅保留 `prefetch` + 本地缓存方案；或者采用预渲染保持挂载以确保切换流畅。

## 下一步
- 我可按以上步骤实现并在 iOS 模拟器进行对比测试（切换前后耗时、首帧表现），再提交具体改动与实测数据。
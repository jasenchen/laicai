import { relative } from 'path';
import { jsxAttribute, jsxIdentifier, stringLiteral,
// @ts-expect-error import from deep path for reduce load files
 } from '@babel/types/lib/builders/generated';
export const createVisitor = ({ cwd = process.cwd(), excludes }) => {
    const isExclude = (excludes === null || excludes === void 0 ? void 0 : excludes.length)
        ? memo((filePath) => pathMatch(filePath, excludes))
        : () => false;
    const pathRelative = memo((filePath) => relative(cwd, filePath));
    const visitor = {
        JSXOpeningElement: {
            enter(path, state) {
                var _a, _b;
                const filePath = (_b = (_a = state === null || state === void 0 ? void 0 : state.file) === null || _a === void 0 ? void 0 : _a.opts) === null || _b === void 0 ? void 0 : _b.filename;
                if (!filePath)
                    return;
                if (isExclude(filePath))
                    return;
                const relativePath = pathRelative(filePath);
                doJSXOpeningElement(path.node, {
                    relativePath,
                });
            },
        },
    };
    return visitor;
};
/**
 * simple path match method, only use string and regex
 */
export const pathMatch = (filePath, matches) => {
    if (!(matches === null || matches === void 0 ? void 0 : matches.length))
        return false;
    return matches.some((match) => {
        if (typeof match === 'string') {
            return filePath.includes(match);
        }
        else if (match instanceof RegExp) {
            return match.test(filePath);
        }
        // default is do not filter when match is illegal, so return true
        return true;
    });
};
const doJSXPathName = (name) => {
    const visitors = {
        JSXIdentifier: doJSXIdentifierName,
        JSXMemberExpression: doJSXMemberExpressionName,
        JSXNamespacedName: doJSXNamespacedNameName,
    };
    return visitors[name.type](name);
};
export const doJSXOpeningElement = (node, option) => {
    var _a, _b;
    const { stop } = doJSXPathName(node.name);
    if (stop)
        return { stop };
    const { relativePath } = option;
    const line = (_a = node.loc) === null || _a === void 0 ? void 0 : _a.start.line;
    const column = (_b = node.loc) === null || _b === void 0 ? void 0 : _b.start.column;
    const lineAttr = isNil(line)
        ? null
        : jsxAttribute(jsxIdentifier('data-inspector-line'), stringLiteral(line.toString()));
    const columnAttr = isNil(column)
        ? null
        : jsxAttribute(jsxIdentifier('data-inspector-column'), stringLiteral(column.toString()));
    const relativePathAttr = jsxAttribute(jsxIdentifier('data-inspector-relative-path'), stringLiteral(relativePath));
    const attributes = [lineAttr, columnAttr, relativePathAttr];
    // Make sure that there are exist together
    if (attributes.every(Boolean)) {
        node.attributes.unshift(...attributes);
    }
    return { result: node };
};
const doJSXIdentifierName = (name) => {
    if (name.name.endsWith('Fragment')) {
        return { stop: true };
    }
    return { stop: false };
};
const doJSXMemberExpressionName = (name) => {
    const { stop } = doJSXIdentifierName(name.property);
    return { stop };
};
const doJSXNamespacedNameName = (name) => {
    const { stop } = doJSXIdentifierName(name.name);
    return { stop };
};
const isNil = (value) => value === null || value === undefined;
const memo = (handler) => {
    const cache = new Map();
    return (arg) => {
        if (cache.has(arg)) {
            return cache.get(arg);
        }
        const result = handler(arg);
        cache.set(arg, result);
        return result;
    };
};
